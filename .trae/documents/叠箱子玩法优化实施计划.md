## 总览
- 目标：在现有 React + Canvas 栈塔游戏中实现动态难度、风力扰动、精准度评分与视觉/音频反馈、预倒预警、相机与 UI（精度条与可调跟随速度）、更真实的滑移 vs 倾倒判定（摩擦/角加速度）、挑战模式与道具加成。
- 插入点：
  - 更新/物理：`src/App.tsx::gameLoop`、`src/PhysicsEngine.ts`
  - 生成/难度：`src/App.tsx::handleClick`、`src/types.ts::DIFFICULTY`
  - 相机/UI：`src/App.tsx::setCameraY`、`src/components/GameCanvas.tsx`
  - 反馈：`src/utils/sound.ts`、`src/utils/particles.ts`、`GameCanvas.onBoxLanded`

## 数据结构与设置
- 扩展类型与设置（`src/types.ts`）
  - 为 `GameState` 增加：`settings = { cameraFollowSpeed: number, windStrength: number, windRotationStrength: number }`、`lastOverlapRatio?: number`、`mode: 'classic'|'timed'|'limited'`、`timeLeft?: number`、`maxBoxes?: number`、`nextPowerup?: 'wider'|'lockRotation'|null`。
  - 为 `Box` 增加：`warning?: boolean`、`precision?: number`（该次落顶的重叠比例）。
  - `DIFFICULTY` 增加函数或表：`widthShrinkPerLevel`、`wobbleAmplitudePerLevel`、`initialRotationPerLevel`。

## 动态难度（宽度缩小、初始摆动与旋转增大）
- 位置：`src/App.tsx::handleClick`
- 伪代码：
```
const level = Math.floor(score / k) // k=5 等
const widthRange = baseWidthRange.shrink(level * DIFFICULTY.widthShrinkPerLevel)
nextBoxWidth = randomBetween(widthRange.min, widthRange.max)
nextBoxHeight = ... // 保持或轻微缩减
const rotAmp = baseInitialRot + level * DIFFICULTY.initialRotationPerLevel
const swayAmp = baseWobble + level * DIFFICULTY.wobbleAmplitudePerLevel
fallingBox.rotationVelocity = randomBetween(-rotAmp, rotAmp)
fallingBox.velocityX += randomBetween(-swayAmp, swayAmp)
```
- 显示与判定沿用现有逻辑，无需更改渲染变换。

## 风力与轻微随机扰动
- 位置：`src/App.tsx::gameLoop`（仅对 `fallingBox` 或上层微量施加）
- 伪代码：
```
if (fallingBox?.isMoving) {
  const t = timeRef.current
  const windVX = noise1D(t, 0.5) * settings.windStrength
  const windRot = noise1D(t+100, 0.5) * settings.windRotationStrength
  fallingBox.velocityX += windVX * dt
  fallingBox.rotationVelocity += windRot * dt
}
```
- `noise1D` 可用简易平滑噪声（指数平滑的随机序列）。提供开关与强度范围确保“可玩但不失控”。

## 精准度评分 + 粒子与音效反馈
- 位置：合法落顶分支（`src/App.tsx`，在 `newBoxes.push` 前后）；触发 `playSuccessSound` 与粒子系统。
- 伪代码：
```
const prev = boxes[boxes.length-1]
const overlap = Math.max(0, Math.min(prev.x+prev.width, curr.x+curr.width) - Math.max(prev.x, curr.x))
const ratio = overlap / Math.min(prev.width, curr.width)
const bonus = Math.round(ratio * BONUS_MAX) // 线性或分段
score += 1 + bonus
curr.precision = ratio
state.lastOverlapRatio = ratio
playSuccessSound(ratio)
onBoxLanded({ x: curr.x+curr.width/2, y: curr.y, ratio }) // 在 Canvas 内按 ratio 触发更多粒子
```
- 在 `GameCanvas.tsx` 的 `onBoxLanded` 中根据 `ratio` 发射粒子数量与颜色梯度。

## 倾倒前预警（闪烁/微抖动）
- 位置：`src/App.tsx::gameLoop` 使用 `analyzeStackStability` 返回的 `[L,R], comX`
- 伪代码：
```
const { supportL, supportR, comX } = analyzeStackStability(boxes)
const margin = TIP_MARGIN_PX
const nearEdge = Math.min(Math.abs(comX-supportL), Math.abs(comX-supportR)) < margin
boxes[topIndex].warning = nearEdge
```
- 位置：`src/components/GameCanvas.tsx` 渲染顶层箱子时：
```
if (box.warning) { ctx.globalAlpha = 0.7 + 0.3*Math.sin(t*10); /* 或细微 jitter */ }
```

## 相机与 UI（跟随速度可调、顶部精度条）
- 跟随速度：`src/App.tsx::setCameraY` 提取 `CAMERA_LERP=settings.cameraFollowSpeed`，默认 0.1，可由 UI 滑杆调整。
- 顶部精度条：`src/components/GameCanvas.tsx` 在 HUD 层绘制：
```
const r = lastOverlapRatio ?? 0
drawBar(topX=10, topY=10, width=GAME_WIDTH-20, height=12, fill= r)
// 同时画上一次支撑范围 [L,R] 的标记线，提升解释性
```

## 物理与判定增强（摩擦滑移 vs 倾倒；角加速度）
- 位置：`src/PhysicsEngine.ts::analyzeStackStability` 与 `src/App.tsx` 倾倒/下滑动量注入处。
- 思路：当 COM 超出支撑边缘：
  - 滑移判定：`F_friction_max = mu * N ~ mu * m * g`，若需要的水平支撑力 `F_req > F_friction_max`，判定为滑移。
  - 倾倒扭矩：`τ ~ m*g*dx`（dx 为 COM 到支撑边缘水平距）；矩形绕边缘的近似转动惯量 `I ~ (1/3)*m*width^2`；角加速度 `α=τ/I`。
- 伪代码：
```
if (comX < supportL || comX > supportR) {
  const dx = Math.abs(comX - clamp(comX, supportL, supportR))
  const m = curr.width*curr.height // 质量近似
  const N = m*GRAVITY
  const Freq = m*GRAVITY*(dx/height) // 近似所需水平力
  const Fmax = MU*N
  if (Freq > Fmax) {
    curr.velocityX += Math.sign(comX - supportR_or_L) * slideAccel * dt
  } else {
    const I = (1/3)*m*curr.width*curr.width
    const tau = m*GRAVITY*dx
    const alpha = tau / I
    curr.rotationVelocity += Math.sign(edgeSide) * alpha * dt
  }
}
```
- 在 `App.tsx` 上层群体下坠时，优先设置角加速度而非固定旋转速度，滑移与倾倒按 `overlap` 与 `mu` 决策。

## 关卡与模式（挑战）
- 位置：`src/App.tsx` 新增 `mode`、`timeLeft` 或 `maxBoxes`；HUD 展示倒计时/剩余数。
- 伪代码（限时）：
```
if (mode==='timed') { timeLeft -= dt; if (timeLeft<=0) gameOver=true }
```
- 伪代码（限量）：
```
if (mode==='limited' && placedCount>=maxBoxes) { gameOver=true }
```
- 目标高度/胜利条件在 HUD 显示并在 `gameOver` 时区分胜败文案。

## 道具与加成
- 位置：`src/App.tsx::handleClick`
- 伪代码：
```
switch (nextPowerup) {
  case 'wider': fallingBox.width *= 1.25; break
  case 'lockRotation': fallingBox.rotationVelocity = 0; break
}
nextPowerup = null
```
- 触发策略：成功若 `ratio>0.9` 给下一次 `wider`；或救援当 `warning` 持续若干帧给一次 `lockRotation`。
- HUD 显示可用道具图标与倒计时。

## 验证与参数校准
- 单元/集成：
  - 检查 `overlapRatio` 计算与分数增减一致性；
  - 在 `MU` 较低/较高两端测试滑移 vs 倾倒切换；
  - 风力强度 0、低、中、高四档下的可玩性；
  - 相机跟随速度 0.05/0.1/0.2 的舒适度对比。
- 可视化：
  - 顶部精度条与支撑区标记与实际判定一致；
  - 预警闪烁在接近边缘时触发，不误报。
- 性能：
  - 保持每帧 O(n) 分析，顶层少量额外计算（α、τ）不造成卡顿。

---
如确认以上方案，我将按上述插入点分阶段提交代码：先实现“动态难度+精准度评分+精度条+预警”，再加“风力与物理增强”，最后补充“挑战模式与道具”。