## 目标
- 为静止堆叠做“承载与重力稳定性”分析：当上方质量与重心超出下方的承载范围时，触发真实的倾倒/滑落模拟。
- 保持“新箱子必须落在上一个箱子顶部”的即时判负规则不变；但对已落稳的堆叠，引入更真实的失稳行为而不是直接结束。

## 方案概览
- 常量：在 `types.ts` 增加摩擦系数 `MU`、最小水平重叠比例 `MIN_OVERLAP_RATIO`、允许的轻微外摆容限 `TIP_MARGIN_PX`。
- 稳定性分析（新）：在 `PhysicsEngine` 增加 `analyzeStackStability(boxes)`：
  - 针对每个支撑界面 i（`boxes[i]` 支撑 `boxes[i+1...]`），计算上方整体质心 `COM_x`（以面积作为质量权重：`mass = width*height`）。
  - 计算界面真实接触范围 `[L, R] = overlapRange(boxes[i], boxes[i+1])`（两个箱子在 x 轴上的交叠区间）。
  - 规则：
    - 若 `R <= L`：直接判为“滑落（无接触）”。
    - 若 `COM_x` 不在 `[L - TIP_MARGIN_PX, R + TIP_MARGIN_PX]`：判为“倾倒（超出支撑边界）”。
    - 若 `overlapWidth / boxes[i+1].width < MIN_OVERLAP_RATIO`：判为“滑落（接触面积不足）”。
    - 否则为稳定。
  - 返回 `{stable: boolean, failingIndex?: number, reason?: 'slide' | 'tip'}`。
- 倾倒/滑落触发（真实模拟）：在 `App.tsx` 游戏循环中：
  - 当掉落箱子落稳加入堆叠后，以及每帧更新静止箱子后，调用 `analyzeStackStability`。
  - 若返回不稳定：
    - 将自 `failingIndex+1` 至顶部的所有箱子标记为 `isMoving = true`，并赋予初始速度：
      - `velocityY += 50`（下坠启动），
      - `velocityX += sign(COM_x - centerOfSupport) * 30`（朝外侧滑动），
      - `rotationVelocity += sign(...) * 30`（产生明显倾倒）。
    - 保持 `gameOver` 为 `false`，让模拟自行运行；当塔真正倒塌（例如有箱子离开支撑、角度超阈或触地越界）再判负。
- 现有即时判负保留：新投放箱子若非落在上一个箱子顶部，仍立即判负（已实现的逻辑不改）。
- 判定游戏结束条件：
  - 保留原有 `checkTowerStability` 的角度与支撑校验，但改为仅在“确实发生倒塌或无支撑”后返回 `false`；
  - 与 `analyzeStackStability` 联动：`analyzeStackStability` 只触发移动，不直接判负。

## 伪代码
- `types.ts`
  - `export const MU = 0.4`
  - `export const MIN_OVERLAP_RATIO = 0.6`
  - `export const TIP_MARGIN_PX = 6`
- `PhysicsEngine.analyzeStackStability(boxes)`
  - `if (boxes.length < 2) return {stable: true}`
  - for i from 0 to boxes.length-2:
    - `upper = boxes[i+1..end]`
    - `COM_x = sum(mass_k * centerX_k) / sum(mass_k)`
    - `[L, R] = overlapRange(boxes[i], boxes[i+1])`
    - `overlapW = R - L`
    - if `overlapW <= 0` → return `{stable:false, failingIndex:i, reason:'slide'}`
    - if `COM_x < L - TIP_MARGIN_PX || COM_x > R + TIP_MARGIN_PX` → return `{stable:false, failingIndex:i, reason:'tip'}`
    - if `overlapW / boxes[i+1].width < MIN_OVERLAP_RATIO` → return `{stable:false, failingIndex:i, reason:'slide'}`
  - return `{stable:true}`
- `App.tsx` 游戏循环中：
  - 更新 `fallingBox` 与 `boxes` 后：`res = PhysicsEngine.analyzeStackStability(newBoxes)`
  - if `!res.stable`:
    - for j in `[res.failingIndex+1 .. newBoxes.length-1]`:
      - `box.isMoving = true`
      - `box.velocityY += 50`
      - `dir = Math.sign(COM_x - ((L+R)/2)) || 1`
      - `box.velocityX += dir * 30`
      - `box.rotationVelocity += dir * 30`
  - 再运行 `checkTowerStability(newBoxes)` 判断是否真正结束。

## 文件与集成点
- `src/types.ts`：新增常量 `MU`、`MIN_OVERLAP_RATIO`、`TIP_MARGIN_PX`。
- `src/PhysicsEngine.ts`：新增函数 `analyzeStackStability` 与 `overlapRange` 辅助；保留并调用现有 `checkTowerStability`。
- `src/App.tsx`：在落稳后与每帧更新后调用分析；对不稳定的上方箱子注入初始运动参数；维持既有掉落与渲染流程。

## 验证
- 用 3–5 个箱子的边缘叠放，逐渐外摆：观察在达到阈值时，上层箱子开始倾倒与滑落，而不是立即结束。
- 当箱子真实掉落并不再被支撑，`checkTowerStability` 返回失败，触发 `gameOver`；音效与分数逻辑保持不变。
- 调参：通过 `MIN_OVERLAP_RATIO` 与 `TIP_MARGIN_PX` 控制“稳定”的严苛程度，`rotationVelocity` 与 `velocityX/Y` 控制倾倒观感。

## 注意
- 保持计算轻量，避免引入复杂刚体库；采用近似的 COM 与支撑范围判定实现真实感与可玩性平衡。
- 与“新箱子必须落在上一个箱子顶部”规则兼容，不改变该即时判负逻辑。