## 目标
- 全站移动端适配：竖屏优先、响应式布局、触摸友好
- 游戏画布：支持手机竖屏分格/整体手机样式，清晰缩放与安全区
- 事件系统：统一为 Pointer 事件，兼容触摸与鼠标

## 当前代码要点
- 画布坐标系固定 `800x600`（`src/types.ts`），DPR 缩放与 CSS 尺寸已处理（`GameCanvas.tsx`）
- 已监听 `resize/orientationchange`，但 HUD 存在硬编码：`barW = GAME_WIDTH - 620`、`panelW = 160`
- 输入事件有鼠标与触摸，无 Pointer 事件；样式层缺少媒体查询与移动断点

## 实施方案
### 1) 响应式布局与视口
- 在 `index.html` 设置移动视口：`width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no`
- 在 `index.css` 增加移动断点：
  - 缩小 `#root` padding（例如 ≤480px 时 0–8px）
  - 保持 `body, #root` 高度 `100vh`，必要时 `overflow: hidden`
- 在 `App.tsx` 外层容器增加移动样式类（如 `mobile`）以按断点切换布局

### 2) 竖屏画布分格/手机样式
- 在 `GameCanvas.tsx` 改造 `calculateCanvasSize`：
  - 竖屏（`height > width`）时优先占满宽度，限定高度 ≤ `100vh`，设最小可读宽度（如 320px）
  - 保持 4:3 游戏坐标系，避免拉伸
- 将 HUD 从右侧改为顶部/底部（竖屏）：
  - 顶部显示分数与状态，底部显示操作提示/精度条
  - 画布内绘制位置从右侧 `panelW` 改为顶部/底部区域，避免挤压主画面

### 3) HUD 尺寸去硬编码与比例化
- 替换 `barW = GAME_WIDTH - 620` 为比例计算：
  - `barW = clamp(GAME_WIDTH * 0.6, 160, GAME_WIDTH - margin*2)`
- 替换 `panelW = 160` 为：`panelW = clamp(GAME_WIDTH * 0.25, 140, 220)`
- 所有 HUD 坐标与字体大小基于 `GAME_WIDTH` 比例缩放，保证小屏清晰与可读

### 4) 事件统一（Pointer 事件）
- 在 `<canvas>` 绑定 `onPointerDown/onPointerMove/onPointerUp`：
  - 将现有 `handleMouseMove`/`handleTouch*` 的坐标映射提取复用
  - `touchAction: 'none'` 保留，阻止浏览器默认手势
- 继续支持 `onClick/onTouchEnd` 触发投放，Pointer 作为主通道，触摸/鼠标为兼容
- 如需滚轮缩放/水平微调，新增 `wheel` 监听并与移动手势区分

### 5) 移动端交互优化
- 底部大按钮（可选）：提供“投放/重开”触控按钮，减少误触
- 防抖与长按：触控开始到结束的最短时间阈值，避免抖动
- 方向变化：根据 `orientationchange` 切换 HUD 布局与字体规模

### 6) 画质与性能
- DPR 缩放保持（已有），在超高 DPR 设备上限制最大实际像素以控内存
- 统一 `requestAnimationFrame` 节流（如 60fps），避免重绘过密

### 7) 验证与调试
- 开发模式：在 iOS Safari/Android Chrome 上验证竖屏与横屏切换
- 检查极窄屏（≤360px）与大屏（平板）可读性与交互

## 代码变更范围
- `index.html`：更新 `meta viewport`
- `src/index.css`：新增媒体查询与高度/滚动控制
- `src/App.tsx`：条件渲染移动控件（可选）与容器类名
- `src/components/GameCanvas.tsx`：
  - 改造 `calculateCanvasSize`
  - HUD 改为比例与顶/底布局
  - 添加 Pointer 事件并复用坐标映射

## 伪代码（关键改造）
- 画布尺寸
```
const isPortrait = window.innerHeight > window.innerWidth
const targetW = isPortrait ? clamp(window.innerWidth, 320, 1024) : window.innerWidth - 20
const targetH = targetW * (GAME_HEIGHT / GAME_WIDTH)
const cssSize = fitWithinViewport(targetW, targetH)
canvas.style.width = cssSize.w; canvas.style.height = cssSize.h
canvas.width = cssSize.w * dpr; canvas.height = cssSize.h * dpr; ctx.scale(dpr, dpr)
```
- HUD 比例与位置
```
const barW = clamp(GAME_WIDTH * 0.6, 160, GAME_WIDTH - margin*2)
const panelW = clamp(GAME_WIDTH * 0.25, 140, 220)
const hudTop = isPortrait ? true : false
drawHUD({ top: hudTop, barW, panelW, fontScale: GAME_WIDTH / 800 })
```
- Pointer 事件统一
```
function toGameCoord(clientX, clientY) {
  const rect = canvas.getBoundingClientRect()
  const x = (clientX - rect.left) * (GAME_WIDTH / rect.width)
  const y = (clientY - rect.top)  * (GAME_HEIGHT / rect.height)
  return { x, y }
}
canvas.onpointerdown = (e) => { e.preventDefault(); const p = toGameCoord(e.clientX, e.clientY); /* start */ }
canvas.onpointermove = (e) => { /* move */ }
canvas.onpointerup   = (e) => { /* release -> drop */ }
```

## 交付
- 按上述范围提交改造，保持现有功能与分数/物理逻辑不变
- 提供在移动设备的预览与验证

请确认是否按此方案执行，或告知希望的 HUD 布局偏好（顶部/底部）与是否需要底部大按钮。